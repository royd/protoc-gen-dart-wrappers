package generate

import (
	"errors"
	"strings"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/pluginpb"
)

func Generate(plugin *protogen.Plugin) error {
	plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

	for _, file := range plugin.Files {
		if !file.Generate {
			continue
		}

		err := generateFile(plugin, file)
		if err != nil {
			return err
		}
	}

	return nil
}

func generateFile(p *protogen.Plugin, f *protogen.File) error {
	// Skip generating file if there is no message.
	if len(f.Messages) == 0 {
		return nil
	}

	filePrefix := f.GeneratedFilenamePrefix

	g := p.NewGeneratedFile(filePrefix+".g.dart", f.GoImportPath)
	g.P("// Code generated by protoc-gen-dart-wrappers. DO NOT EDIT.")
	g.P()

	// begin imports
	g.P("import '", filePrefix, ".pb.dart' as pb;")
	g.P("")
	// end imports

	for _, m := range f.Messages {
		className := toClassName(m)
		messageName := toMessageName(m)

		g.P("class ", className, " {")

		// begin constructor
		g.P("  ", className, "({")

		for _, f := range m.Fields {
			fieldName := toFieldName(f)
			if isRequired(f) {
				g.P("    ", "required this.", fieldName, ",")
			} else {
				g.P("    ", "this.", fieldName, ",")
			}
		}
		g.P("  });")
		g.P("")
		// end constructor

		// begin factory
		g.P("  factory ", className, ".fromProto(pb.", messageName, " msg) {")
		for _, f := range m.Fields {
			fieldName := toFieldName(f)
			if isRequired(f) {
				g.P("    if (!msg.has", f.GoName, "()) {")
				g.P("      throw ArgumentError.notNull('", fieldName, "');")
				g.P("    }")
				g.P("")
			}
		}

		g.P("    return ", className, "(")
		for _, f := range m.Fields {
			fieldName := toFieldName(f)
			if f.Message != nil {
				g.P("      ", fieldName, ": ", toClassName(f.Message), ".fromProto(msg.", fieldName, "),")
			} else if f.Enum != nil {
				g.P("      ", fieldName, ": ", toEnumName(f.Enum), ".fromProto(msg.", fieldName, "),")
			} else {
				g.P("      ", fieldName, ": msg.", fieldName, ",")
			}
		}
		g.P("    );")
		g.P("  }")
		g.P("")
		// end factory

		// begin fields
		for _, f := range m.Fields {
			t, err := dartType(f)
			if err != nil {
				return err
			}

			if isRequired(f) {
				g.P("  final ", t, " ", f.Desc.Name(), ";")
			} else {
				g.P("  final ", t, "? ", f.Desc.Name(), ";")
			}

		}
		g.P("")
		// end fields

		// begin toProto
		g.P("  pb.", messageName, " toProto() {")
		g.P("    return pb.", messageName, "(")
		for _, f := range m.Fields {
			fieldName := toFieldName(f)
			if f.Message != nil || f.Enum != nil {
				g.P("      ", fieldName, ": ", fieldName, ".toProto(),")
			} else {
				g.P("      ", fieldName, ": ", fieldName, ",")
			}
		}
		g.P("    );")
		g.P("  }")
		// end toProto

		g.P("}")
		g.P("")
	}

	// begin enums
	for _, e := range f.Enums {
		name := toEnumName(e)
		g.P("enum ", name, " {")
		for i, v := range e.Values {
			isLast := i == len(e.Values)-1
			if !isLast {
				g.P("  ", toEnumValue(v), ",")
			} else {
				g.P("  ", toEnumValue(v), ";")
			}
		}
		g.P("")

		// begin factory
		g.P("  factory ", name, ".fromProto(pb.", name, " en) =>")
		g.P("    ", name, ".values.firstWhere((e) => e.index == en.value);")
		g.P("")
		// end factory

		// begin toProto
		g.P("  pb.", name, " toProto() => pb.", name, ".valueOf(this.index)!;")
		// end toProto
		g.P("}")
	}

	// end enums

	return nil
}

func dartType(f *protogen.Field) (string, error) {
	kind := f.Desc.Kind()

	value := ""
	var err error

	switch kind {
	case protoreflect.StringKind:
		value = "String"
	case protoreflect.MessageKind:
		value = toClassName(f.Message)
	case protoreflect.EnumKind:
		value = toEnumName(f.Enum)
	default:
		err = errors.New("unsupported type " + kind.String())
	}

	return value, err
}

func isRequired(f *protogen.Field) bool {
	return !f.Desc.HasOptionalKeyword()
}

func toFieldName(f *protogen.Field) string {
	return string(f.Desc.Name())
}

func toLowerCase(str string) string {
	return strings.ToLower(str)
}

func toTitleCase(str string) string {
	caser := cases.Title(language.English)

	return caser.String(str)
}

func toClassName(m *protogen.Message) string {
	return string(m.Desc.Name())
}

func toMessageName(m *protogen.Message) string {
	return string(m.Desc.Name())
}

func toEnumName(e *protogen.Enum) string {
	return string(e.Desc.Name())
}

func toEnumValue(v *protogen.EnumValue) string {
	return string(v.Desc.Name())
}
